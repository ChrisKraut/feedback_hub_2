---
description:Modular DDD React Frontend Project Structure
This document outlines a modular directory structure for a  application based on the principles of Domain-Driven Design (DDD). The goal is to create a highly scalable and maintainable backend architecture by organizing features into self-contained business domains, or "modules." Each module contains everything it needs to function.

Core Principles
Package by Domain: The primary organization is by business domain (e.g., users, orders, products), not by technical layer (components, pages, services).

High Cohesion: All code related to a single domain lives together, making it easy to find and understand.

Low Coupling: Domains should be independent and have zero knowledge of other domains. They communicate only through a shared, generic layer.

Explicit Public API: Each domain explicitly exports only what other parts of the application are allowed to use (e.g., its main page component, a state selector). Everything else is kept private to the module.

Example Directory Structure Overview
/src
├── domains/
│   ├── users/
│   │   ├── api/
│   │   │   ├── userApi.ts
│   │   │   └── userMappers.ts
│   │   ├── components/
│   │   │   ├── UserProfileForm.tsx
│   │   │   └── UserAvatar.tsx
│   │   ├── domain/
│   │   │   ├── User.ts
│   │   │   └── Email.ts
│   │   ├── hooks/
│   │   │   └── useUserData.ts
│   │   ├── pages/
│   │   │   └── UserProfilePage.tsx
│   │   ├── state/
│   │   │   └── userSlice.ts
│   │   └── index.ts  // Public API of the 'users' domain
│   │
│   └── orders/
│       ├── api/
│       ├── components/
│       ├── domain/
│       ├── pages/
│       ├── state/
│       └── index.ts // Public API of the 'orders' domain
│
├── shared/
│   ├── components/
│   │   ├── Button.tsx
│   │   └── Input.tsx
│   ├── hooks/
│   │   └── useDebounce.ts
│   ├── lib/
│   │   └── apiClient.ts
│   └── types/
│       └── index.ts
│
├── app/
│   ├── App.tsx
│   ├── Router.tsx
│   └── store.ts
│
└── main.tsx

Detailed Layer Breakdown

domains This is the new heart of the application. Each subdirectory is a self-contained business domain.
domains/users/: A module representing the "User Management" domain.

api/: Contains everything related to data fetching for this domain. userApi.ts would define the API calls (e.g., using RTK Query or a custom fetch wrapper), and userMappers.ts would handle the transformation between raw API data and the domain models.

components/: React components that are only used within the users domain.

domain/: The pure business logic, models, and rules for this domain. This part remains framework-agnostic. User.ts and Email.ts are the core business entities and value objects.

hooks/: React hooks that are specific to the users domain, like a useUserData() hook that encapsulates the logic for fetching and accessing user data.

pages/: The top-level page components for this domain, like UserProfilePage.tsx. These are the entry points into the module's UI.

state/: State management logic for this domain, such as a userSlice.ts for Redux Toolkit.

index.ts: The Public API of the Module. This is a critical file. It explicitly exports only what needs to be accessible from outside the users module. For example:

// domains/users/index.ts
export { UserProfilePage } from './pages/UserProfilePage';
export { userReducer } from './state/userSlice';
export { selectUserById } from './state/userSlice';
// Note: UserProfileForm, userApi, etc., are NOT exported.

shared This layer contains truly generic, application-agnostic code. A domain must take what is in shared as-is. It cannot be tailored for a specific domain. If a component needs customization, it should probably live inside the domain itself.
components/: Purely presentational, generic components like Button, Input, Modal, Spinner. They have no business logic.

hooks/: Generic hooks like useToggle, useDebounce.

lib/: Shared library configurations, like a singleton apiClient (e.g., an Axios instance) that can be used by the api layer of each domain.

types/: Global TypeScript types (e.g., ApiError, Status).

app This top-level directory is now very thin. Its only job is to assemble the different domains and the shared pieces into a running application.
App.tsx: The root component of the application, often setting up providers (Redux Store, Theme, etc.).

Router.tsx: Defines the application's routes. It imports page components from the public APIs of the different domains (e.g., import { UserProfilePage } from '@/domains/users';).

store.ts: The root Redux store (or equivalent). It combines the reducers that are exported from each domain's index.ts file.

How It All Connects: An Example Flow
App Setup: The main store.ts imports userReducer from '@/domains/users' and ordersReducer from '@/domains/orders' to create the global state. The Router.tsx imports UserProfilePage from '@/domains/users'.

Navigation: The user navigates to /profile. The router renders the UserProfilePage.

Data Fetching: Inside the UserProfilePage, the useUserData hook is called. This hook dispatches an async thunk defined in userSlice.ts.

API Call: The thunk calls a function from userApi.ts, which uses the shared apiClient to make a network request.

Domain Mapping: The response data is passed through a mapper in userMappers.ts to convert the plain API object into a User domain entity.

State Update: The result is stored in the userSlice, and the UserProfilePage re-renders with the data. All of this happens entirely within the domains/users module, which only relied on the generic apiClient from the shared layer.
globs:
alwaysApply: false
---
